{"title":"Raster Data Analysis","markdown":{"headingText":"Raster Data Analysis","containsRefs":false,"markdown":"So far, we have exclusively focused on the use of vector and tabular data. However, depending on the nature of your research problem, you may also encounter *raster data*. This week's content introduces you to raster data, map algebra, and interpolation. \n\n## Lecture slides {#slides-w06}\nYou can download the slides of this week's lecture here: [[Link]]({{< var slides.week06 >}}).\n\n## Reading list {#reading-w06}\n#### Essential readings {.unnumbered}\n- Gimond, M. 2021. Intro to GIS and spatial analysis. **Chapter 14**: *Spatial Interpolation*. [[Link]](https://mgimond.github.io/Spatial/spatial-interpolation.html)\n- Heris, M., Foks, N., Bagstad, K. 2020. A rasterized building footprint dataset for the United States. *Scientific Data* 7: 207. [[Link]](https://doi.org/10.1038/s41597-020-0542-3)\n- Thomson, D., Leasure, D., Bird, T. *et al*. 2022. How accurate are WorldPop-Global-Unconstrained gridded population data at the cell-level? A simulation analysis in urban Namibia. *Plos ONE* 17:7: e0271504. [[Link]](https://doi.org/10.1371/journal.pone.0271504)\n\n#### Suggested readings {.unnumbered}\n- Mellander, C., Lobo, J., Stolarick, K. *et al*. 2015. Night-time light data: A good proxy measure for economic activity? *PLoS ONE* 10(10): e0139779. [[Link]](https://doi.org/10.1371/journal.pone.0139779)\n\n## Population change in London\nFor the first part of this week's practical material we will be using raster datasets from [WorldPop](https://hub.worldpop.org/). These population surfaces are estimates of counts of people, displayed within a regular grid raster of a spatial resolution of up to 100m. These datasets can be used to explore, for example, changes in the demographic profiles or area deprivation at small spatial scales.\n\n1. Navigate to the WorldPop Hub: [[Link]](https://hub.worldpop.org/)\n2. Go to **Population Count** -> **Unconstrained individual countries 2000-2020 (1km resolution)**.\n3. Type *United Kingdom* in the search bar.\n4. Download the [GeoTIFF](https://en.wikipedia.org/wiki/GeoTIFF) files for **2010** and **2020**: `gbr_ppp_2010_1km_Aggregated` and `gbr_ppp_2020_1km_Aggregated`.\n5. Save the files to your computer in your `data` folder.\n\n::: {.callout-note}\nThe key difference between vector and raster models lies in their structure. Vectors are made up of points, lines, and polygons. In contrast, raster data consists of pixels (or grid cells), similar to an image. Each cell holds a single value representing a geographic phenomenon, such as population density at that location. Common raster data types include remote sensing imagery, such as satellite or LIDAR data.\n::: \n\n::: {.callout-note}\nA GeoTIFF is a type of raster file format that embeds geographic information, enabling the image to be georeferenced to specific real-world coordinates. It includes metadata like projection, coordinate system, and geographic extent, making it compatible with GIS software for spatial analysis.\n:::\n\nTo focus the analysis on London, we need to clip our dataset to the boundaries of the city. For this, we will use the London Borough boundaries, which can be downloaded from the link below. Be sure to save the files in the data folder within your `data` directory.\n\n| File                                        | Type   | Link |\n| :------                                     | :------| :------ |\n| London Borough Spatial Boundaries           | `GeoPackage` | [Download](https://github.com/jtvandijk/GEOG0030/raw/refs/heads/main/data/spatial/London-Boroughs.gpkg) |\n\nOpen a new script within your `GEOG0030` project and save this as `w06-raster-data-analysis.r`. \n\nBegin by loading the necessary libraries:\n\n```{r}\n#| label: 06-load-libraries\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| output: False\n#| tidy: True\n#| filename: 'R code'\n# load libraries\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(openair)\nlibrary(gstat)\nlibrary(sf)\nlibrary(tmap)\n```\n\n::: {.callout-warning}\nYou may have to install some of these libraries if you have not used these before.\n:::\n\n### Map algebra\nWe will be using some simple map algebra to look at population change in London between 2010 and 2020. We can load the individual `GeoTiff` files that we downloaded into R and reproject them into British National Grid using the `terra` library.\n\n```{r}\n#| label: 06-load-raster\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# load data\npop2010 <- rast('data/spatial/gbr_ppp_2010_1km_Aggregated.tif')\npop2020 <- rast('data/spatial/gbr_ppp_2020_1km_Aggregated.tif')\n\n# transform projection\npop2010 <- pop2010 |> project('EPSG:27700')\npop2020 <- pop2020 |> project('EPSG:27700')\n```\n\nCarefully examine each dataframe to understand its structure and the information it contains:\n\n```{r}\n#| label: 06-inspect-raster\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# inspect 2010 data\nhead(pop2010)\n\n# inspect 2020 data\nhead(pop2020)\n```\n::: {.callout-note}\nA raster file is always rectangular, with areas lacking data stored as `NA`. For our population data, this means any pixels outside the land borders of Great Britain will have by definition an `NA` value.\n:::\n\n::: {.callout-tip}\nYou can further inspect the results using the `View()` function. \n:::\n\nWe can also plot the raster files for visual inspection:\n\n```{r}\n#| label: fig-06-load-raster-data-2010\n#| fig-cap: WorldPop 2010 population estimates for the United Kingdom.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# plot 2010\nplot(pop2010)\n```\n\n```{r}\n#| label: fig-06-load-raster-data-2020\n#| fig-cap: WorldPop 2020 population estimates for the United Kingdom.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# plot 2020\nplot(pop2020)\n```\n\nYou will notice that while the maps appear similar, the legend indicates a significant increase in values over the decade from 2010 to 2021, with the maximum rising from approximately 12,000 people per cell to over 14,000. \n\nNow that we have our raster data loaded, we will focus on reducing it to display only the extent of London. We will use the London borough `GeoPackage`\n\n::: {.callout-tip}\nThe `terra` package does not accept `sf` objects, so after loading the London borough boundaries, we need to convert the file into a `SpatRaster` or `SpatVector`.\n:::\n\n```{r}\n#| label: 06-clip-to-london\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# load data, to spatvector\nborough <- st_read('data/spatial/London-Boroughs.gpkg') |>\n  vect()\n\n# crop to extent\npop2010_london <- crop(pop2010, borough)\npop2020_london <- crop(pop2020, borough)\n\n# mask to boundaries\npop2010_london <- mask(pop2010_london, borough)\npop2020_london <- mask(pop2020_london, borough)\n```\n\nWe should now have the raster cells that fall within the boundaries of London:\n\n```{r}\n#| label: fig-06-load-raster-data-2010-lon\n#| fig-cap: WorldPop 2010 population estimates for London.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# inspect\nplot(pop2010_london)\n```\n\n```{r}\n#| label: fig-06-load-raster-data-2020-lon\n#| fig-cap: WorldPop 2020 population estimates for London.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# inspect\nplot(pop2020_london)\n```\n\nNow we have our two London population rasters, we can calculate population change between the two time periods by subtracting our 2010 population raster from our 2020 population raster:\n  \n```{r}\n#| label: fig-07-subtract-london\n#| fig-cap: Population change in London 2010-2020.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# subtract\nlonpop_change <- pop2020_london - pop2010_london\n\n# inspect\nplot(lonpop_change)\n```\n\n### Zonal statistics\nTo further analyse our population change raster, we can create a smoothed version of the `lonpop_change` raster using the `focal()` function. This function generates a raster that calculates the average (mean) value of the nearest neighbours for each cell.\n\n```{r}\n#| label: fig-06-focus-on-the-hood\n#| fig-cap: Smoothed version of population change in London 2010-2020.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# smooth\nlonpop_smooth <- focal(lonpop_change, w = matrix(1,3,3), fun = mean) \n\n# inspect\nplot(lonpop_change)\n```\n\nThe differences may not be immediately apparent, but if you subtract the smoothed raster from the original raster, you will clearly see that changes have occurred.\n\n```{r}\n#| label: fig--6-focus-on-the-smooth\n#| fig-cap: Difference smoothed population change with original population change raster.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# substract\nlonpop_chang_smooth <- lonpop_change - lonpop_smooth\n\n# inspect\nplot(lonpop_chang_smooth)\n```\n\nWe can also use zonal functions to better represent population change by aggregating the data to coarser resolutions. For example, resizing the raster's spatial resolution to contain larger grid cells simplifies the data, making broader trends more visible. However,it may also end up obfuscating more local patterns. \n\n::: {.callout-tip}\nWe can resize a raster using the `aggregate() function`, setting the `factor` parameter to the scale of resampling desired (e.g. doubling both the width and height of a cell). The `function` parameter determines how to aggregate the data.\n:::\n\n```{r}\n#| label: fig-06-aggregate-the-raster\n#| fig-cap: Aggregated cell values. \n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# aggregate\nlonpop_agg <- aggregate(lonpop_change, fact = 2, fun = mean) \n\n# inspect\nplot(lonpop_agg)\n```\n\nWe can also aggregate raster cells to vector geographies. For example, we can aggregate the WorldPop gridded population estimates to the London borough boundaries:\n\n```{r tidy='styler'}\n#| label: fig-06-aggregate-the-raster-to-vector\n#| fig-cap: Absolute population change in London boroughs 2010-2020.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n# aggregate \nlondon_borough_pop <- extract(lonpop_change, borough, fun=sum)\n\n# bind to spatial boundaries\nborough <- borough |> \n  st_as_sf() |>\n  mutate(pop_change = london_borough_pop$gbr_ppp_2020_1km_Aggregated)\n\n# shape, polygon\ntm_shape(borough) +\n\n  # specify column, classes\n  tm_polygons(\n    col = 'pop_change',\n    palette = c('#f1eef6', '#bdc9e1', '#74a9cf', '#0570b0'),\n    title = '',\n  ) +\n  # set layout\n  tm_layout(\n    legend.outside = FALSE,\n    legend.position = c('right', 'bottom'),\n    frame = FALSE\n  )\n```\n::: {.callout-tip}\nYou can further inspect the results using the `View()` function. \n:::\n\nWe now have a vector dataset, which allows us to perform many of the analyses we have explored in previous weeks. \n\n::: {.callout-tip}\nCalculating population change, particularly over decades as we have done, can be challenging due to changes in administrative boundaries. Using raster data offers a helpful workaround, provided the rasters are of consistent size and extent.\n:::\n\n## Air pollution in London\nIn the second part of this week's practical, we will explore various methods of spatial data interpolation, focusing on air pollution in London using data from [Londonair](https://www.londonair.org.uk/). We will specifically look at Nitrogen Dioxide (NO~2~) measurements.\n\n::: {.callout-note}\nLondonair is the website of the London Air Quality Network (LAQN), which provides air pollution data for London and southeast England through the [Environmental Research Group](https://www.imperial.ac.uk/school-public-health/environmental-research-group/) at Imperial College This data is publicly available and can be accessed directly using the `openair` R package, without needing to download files.\n:::\n\n::: {.callout-note}\nSpatial interpolation predicts a phenomenon at unmeasured locations. It is often used when we want to estimate a variable across space, particularly in areas with sparse or no data.\n::: \n\n```{r}\n#| label: 06-get-air-pollution-data\n#| classes: styled-output\n#| echo: True\n#| eval: False\n#| tidy: True\n#| filename: 'R code'\n# get list of all measurement sites \nsite_meta <- importMeta(source = 'kcl', all=TRUE, year=2023:2023)\n\n# download all data pertaining to these sites\npollution <- importKCL(site=c(site_meta$code), year=2023:2023, pollutant='no2',meta=TRUE)\n```\n\n::: {.callout-tip}\nNot all measurements sites collect data on NO~2~ so it is normal to get some `404 Not Found` warnings.\n:::\n\n::: {.callout-warning}\nThis code may take some time to run, as it will attempt to download data from all air measurement sites for an entire year, with many measurements taken hourly. If you experience too many errors or if it is taking too long, you can download a copy of the data here: [[Download]](https://github.com/jtvandijk/GEOG0030/raw/refs/heads/main/data/attributes/London-NO2-2023.zip). Once downloaded, place the `zip` file in your `data` folder. The file is large, so you can leave it unzipped.\n:::\n\nLet us start by loading and inspecting the data:\n\n```{r}\n#| label: 06-inspect-air-pollution-data\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# load from zip if downloaded through the link\npollution <- read_csv('data/attributes/London-Pollution-2023.csv.zip')\n\n# inspect\nhead(pollution)\n```\n\nIn the first five rows, we can see data from the same site, with the date field showing an observation for every hour. Given there are 24 hours in a day, 365 days in a year, and data from hundreds of sites, it is no surprise that the dataset is so large. To make the dataset more manageable, let us summarise the values by site.\n\n```{r}\n#| label: 06-mean-air-pollution-data\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# mean site values\npollution_avg <- pollution |>\n  filter(!is.na(latitude) & !is.na(longitude) & !is.na(no2)) |>\n  group_by(code, latitude, longitude) |>\n  summarise(no2 = mean(no2))\n\n# inspect\nhead(pollution_avg)\n```\n\nWe now have 177 measurement sites with their corresponding latitudes, longitudes, and average NO~2~ values. Let us have a look at the spatial distribution of these measurement sites.\n\n```{r tidy='styler'}\n#| label: fig-06-air-quality-measurement-sites\n#| fig-cap: KCL NO~2~ measurement sites in London.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n# load boroughs for background\nborough <- st_read('data/spatial/London-Boroughs.gpkg') |>\n  st_union()\n\n# create a point spatial dataframe\nmeasurement_sites <- pollution_avg |>\n  st_as_sf(coords=c('longitude','latitude'), crs=4326) |>\n  st_transform(27700)\n\n# clip measurement sites to london boundaries\nmeasurement_sites <- measurement_sites |>\n  st_intersection(borough)\n\n# shape, polygon\ntm_shape(borough) +\n  \n  # specify column, classes\n  tm_polygons(\n    col = '#f0f0f0', \n  ) +\n  \n# shape, points\ntm_shape(measurement_sites) + \n  \n  # specify column, colours\n  tm_symbols(\n    col = '#fc9272',\n    size = 0.3,\n  ) +\n  \n  # set legend\n  tm_add_legend(\n    type = 'symbol', \n    labels = 'Measurement site', \n    col = '#fc9272',\n    size = 0.5\n  ) +\n  \n  # set layout\n  tm_layout(\n    legend.outside = FALSE,\n    legend.position = c('right', 'bottom'),\n    legend.text.size = 1,\n    frame = FALSE\n  )\n```\n\nWe can also use proportional symbols to visualise the values, helping us observe how measurements vary across London.'\n\n```{r tidy='styler'}\n#| label: fig-06-air-quality-measurement-sites-proportional-symbol\n#| fig-cap: Proportional symbol map of average KCL NO~2~ measurement in London.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n# shape, polygon\ntm_shape(borough) +\n  \n  # specify column, classes\n  tm_polygons(\n    col = '#f0f0f0', \n  ) +\n  \n# shape, points\ntm_shape(measurement_sites) + \n  \n  # specify column\n  tm_bubbles(\n    size = 'no2',\n    title.size = 'Average reading'\n  ) +\n  \n  # set layout\n  tm_layout(\n    legend.outside = FALSE,\n    legend.position = c('right', 'bottom'),\n    legend.text.size = 1,\n    frame = FALSE\n  )\n\n```\n\n@fig-06-air-quality-measurement-sites-proportional-symbol shows heterogeneity in average NO~2~ measurements across London, both in terms of coverage and NO~2~ levels. To make reasonable assumptions about NO~2~ levels in areas without measurements, we can interpolate the missing values.\n\n### Voronoi tessellation\nA straightforward method for interpolating values across space is to create a Voronoi tessellation polygons. These polygons define the boundaries of areas closest to each unique point, meaning that each point in the dataset has a corresponding Thiessen polygon.\n\n::: {.callout-tip}\nIn addition to Voronoi tessellation, you may encounter the term Thiessen polygons. These terms are often used interchangeably to describe the geometry created from point data.\n:::\n\n``` {r}\n#| label: 06-voronoi\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# function\nst_voronoi_points <- function(points) {\n  \n    # to multipoint\n    g = st_combine(st_geometry(points))\n\n    # to voronoi\n    v = st_voronoi(g)\n    v = st_collection_extract(v)\n\n    # return\n    return(v[unlist(st_intersects(points, v))])\n}\n\n# voronoi tessellation\nmeasurement_sites_voronoi <- st_voronoi_points(measurement_sites)\n\n# replace point geometry with polygon geometry\nmeasurement_sites_tesselation <- measurement_sites |>\n  st_set_geometry(measurement_sites_voronoi) |>\n  st_intersection(borough)\n\n# inspect\nmeasurement_sites_tesselation\n```\n\n::: {.callout-warning}\nDo not worry about fully understanding the code behind the function; just know that it takes a point spatial data frame as input and produces a Thiessen polygon spatial data frame as output.\n:::\n\n::: {.callout-tip}\nYou can further inspect the results using the `View()` function. \n:::\n\nWe can now visualise the results of the interpolation:\n\n```{r tidy='styler'}\n#| label: fig-06-air-quality-london-thiessen\n#| fig-cap: Interpolation of average NO~2~ measurements in London using a Voronoi tessellation.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n# shape, polygon\ntm_shape(measurement_sites_tesselation) +\n\n  # specify column, classes\n  tm_polygons(\n    col = 'no2',\n    palette = c('#ffffcc', '#c2e699', '#78c679', '#0570b0'),\n    title = 'Average reading',\n  ) +\n  # set layout\n  tm_layout(\n    legend.outside = FALSE,\n    legend.position = c('right', 'bottom'),\n    frame = FALSE\n  )\n\n```\n\n#### Inverse Distance Weighting\nA more sophisticated method for interpolating point data is Inverse Distance Weighting (IDW). IDW converts numerical point data into a continuous surface, allowing for visualisation of how the data is distributed across space. This technique estimates values at each location by calculating a weighted average from nearby points, with the weights inversely related to their distances.\n\n::: {.callout-note}\nThe distance weighting is done by a power function: the larger the power coefficient, the stronger the weight of nearby point. The output is most commonly represented as a raster surface. \n:::\n\nWe will start by generating an empty grid to store the predicted values before running the IDW.\n\n``` {r}\n#| label: 06-idw\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| cache: True\n#| filename: 'R code'\n# create regular output grid\noutput_grid <- borough |>\n  st_make_grid(cellsize = c(1000,1000))\n\n# execute \nmeasurement_sites_idw <- idw(formula = no2 ~ 1,\n                             locations = measurement_sites,\n                             newdata = output_grid,\n                             beta = 2)\n\n# clip\nmeasurement_sites_idw <- measurement_sites_idw |>\n  st_intersection(borough)\n```\n\n::: {.callout-warning}\nThe IDW may take some time to run.\n:::\n\nAgain, we can map the results for visual inspection.\n\n::: {.callout-tip}\nThe values of the IDW output are stored in the raster grid as `var1.pred`.\n:::\n\n```{r tidy='styler'}\n#| label: fig-06-air-quality-idw\n#| fig-cap: Interpolation of average NO~2~ measurements in London using Inverse Distance Weighting.\n#| echo: True\n#| eval: True\n# shape, polygon\ntm_shape(measurement_sites_idw) +\n\n  # specify column, classes\n  tm_fill(\n    col = 'var1.pred',\n    style = 'cont',\n    palette = 'Oranges',\n    title = 'Average reading'\n  ) +\n  \n  # set layout\n  tm_layout(\n    legend.outside = FALSE,\n    legend.position = c('right', 'bottom'),\n    frame = FALSE\n  )\n```\n\n::: {.callout-note}\nWe have set the output cell size to 1000x1000 metres. While a smaller cell size can yield a smoother IDW output, it may introduce uncertainty due to the limited number of data points available for interpolation. Additionally, reducing the cell size will exponentially increase processing time.'\n:::\n\n## Assignment \nHaving run through all the steps during the tutorial, we can conduct some more granular analysis of the NO~2~ measurements. For example, instead of examining the annual average measurements, we could compare data across different months. Please try the following tasks:\n\n1. Create monthly averages for the pollution data.\n2. For both *June* and *December*, generate a dataframe containing the London monitoring sites along with their average NO₂ readings for these months.\n3. Perform Inverse Distance Weighting (IDW) interpolation for the data from both months.\n4. Combine the results to assess the differences between these months.\n\n## Before you leave \nThis week, we have explored raster datasets and how to manage and process them using the `terra` library. While you will typically encounter vector data, particularly in relation to government statistics and administrative boundaries, there are also many use cases where raster data may be encountered. With that being said: [that is it for this week](https://www.youtube.com/watch?v=8iwBM_YB1sE)! \n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":false,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["assets/styles.css"],"toc":true,"toc-depth":4,"highlight-style":"atom-one","number-sections":true,"output-file":"06-raster.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","editor":"source","_quarto-vars":{"meta":{"title":"GEOG0030"},"urls":{"w01":"01-spatial.html","w02":"02-point-pattern.html","w03":"03-operations.html","w04":"04-autocorrelation.html","w05":"05-models.html","w06":"06-raster.html","w07":"07-geodemographics.html","w08":"08-network.html","w09":"09-datavis.html","w10":"10-maps.html"},"slides":{"week01":"https://github.com/jtvandijk/GEOG0030/tree/master/slides/w01-geo.pdf","week02":"https://github.com/jtvandijk/GEOG0030/tree/master/slides/w02-geo.pdf","week03":"https://github.com/jtvandijk/GEOG0030/tree/master/slides/w03-geo.pdf","week04":"https://github.com/jtvandijk/GEOG0030/tree/master/slides/w04-geo.pdf","week05":"https://github.com/jtvandijk/GEOG0030/tree/master/slides/w05-geo.pdf","week06":"https://github.com/jtvandijk/GEOG0030/tree/master/slides/w06-geo.pdf","week07":"https://github.com/jtvandijk/GEOG0030/tree/master/slides/w07-geo.pdf","week08":"https://github.com/jtvandijk/GEOG0030/tree/master/slides/w08-geo.pdf","week09":"https://github.com/jtvandijk/GEOG0030/tree/master/slides/w09-geo.pdf","week10":"https://github.com/jtvandijk/GEOG0030/tree/master/slides/w10-geo.pdf"}},"theme":{"light":"flatly","dark":"darkly"},"callout-appearance":"simple","smooth-scroll":true,"number-depth":4,"pagetitle":"{{< var meta.title >}}"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}