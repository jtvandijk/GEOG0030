{"title":"Spatial Queries and Geometric Operations","markdown":{"headingText":"Spatial Queries and Geometric Operations","containsRefs":false,"markdown":"This week, we look at geometric operations and spatial queries: the fundamental building blocks when it comes to spatial data processing and analysis. This includes operations such as aggregating point data, calculating the distances separating one or more spatial objects, running a *buffer* analysis, and *intersecting* different spatial layers.\n\n## Lecture slides\nYou can download the slides of this week's lecture here: [[Link]]({{< var slides.week02 >}}).\n\n## Reading list \n#### Essential readings {.unnumbered}\n- Longley, P. *et al.* 2015. *Geographic Information Science & Systems*, **Chapter 2**: *The Nature of Geographic Data*, pp. 33-54. [[Link]](https://ucl.rl.talis.com/link?url=https%3A%2F%2Fapp.knovel.com%2Fhotlink%2Ftoc%2Fid%3AkpGISSE001%2Fgeographic-information-science%3Fkpromoter%3Dmarc&sig=e437927b963cc591dcb65491eccdd3869cc31aef80e1443cb2ba12d8f3bb031a)\n- Longley, P. *et al.* 2015. *Geographic Information Science & Systems*, **Chapter 3**: *Representing Geography*, pp. 55-76. [[Link]](https://ucl.rl.talis.com/link?url=https%3A%2F%2Fapp.knovel.com%2Fhotlink%2Ftoc%2Fid%3AkpGISSE001%2Fgeographic-information-science%3Fkpromoter%3Dmarc&sig=e437927b963cc591dcb65491eccdd3869cc31aef80e1443cb2ba12d8f3bb031a)\n- Longley, P. *et al.* 2015. *Geographic Information Science & Systems*, **Chapter 7**: *Geographic Data Modeling*, pp. 152-172.  [[Link]](https://ucl.rl.talis.com/link?url=https%3A%2F%2Fapp.knovel.com%2Fhotlink%2Ftoc%2Fid%3AkpGISSE001%2Fgeographic-information-science%3Fkpromoter%3Dmarc&sig=e437927b963cc591dcb65491eccdd3869cc31aef80e1443cb2ba12d8f3bb031a)\n- Longley, P. *et al.* 2015. *Geographic Information Science & Systems*, **Chapter 13**: *Spatial Data Analysis*, pp. 290-318. [[Link]](https://ucl.rl.talis.com/link?url=https%3A%2F%2Fapp.knovel.com%2Fhotlink%2Ftoc%2Fid%3AkpGISSE001%2Fgeographic-information-science%3Fkpromoter%3Dmarc&sig=e437927b963cc591dcb65491eccdd3869cc31aef80e1443cb2ba12d8f3bb031a)\n\n#### Suggested readings {.unnumbered}\n- Lovelace, R., Nowosad, J. and Muenchow, J. 2021. *Geocomputation with R*, **Chapter 4**: *Spatial data operations*. [[Link]](https://geocompr.robinlovelace.net/spatial-operations.html)\n- Lovelace, R., Nowosad, J. and Muenchow, J. 2021. *Geocomputation with R*, **Chapter 5**: *Geometry operations*. [[Link]](https://geocompr.robinlovelace.net/geometry-operations.html)\n- Lovelace, R., Nowosad, J. and Muenchow, J. 2021. *Geocomputation with R*, **Chapter 6**: *Reprojecting geographic data*. [[Link]](https://geocompr.robinlovelace.net/reproj-geo-data.html)\n\n## Bike theft in London I\nThis week, we will examine to what extent reported bicycle theft in London cluster around train and underground stations. We will be using open data from [data.police.uk](https://data.police.uk/) on reported crimes alongside [OpenStreetMap](https://www.openstreetmap.org/#map=6/54.91/-3.43) data for this analysis. We will use R to directly download the necessary data from OpenStreetMap, but the crime data will need to be manually downloaded from the data portal. We further have access to a `GeoPackage` that contains the London 2021 MSOA boundaries that we can use as reference layer. If you do not already have it on your computer, save this file in your `data/spatial` folder.\n\n| File                                        | Type   | Link |\n| :------                                     | :------| :------ |\n| London MSOA 2021 Spatial Boundaries         | `GeoPackage` | [Download](https://github.com/jtvandijk/GEOG0030/raw/refs/heads/main/data/spatial/London-MSOA-2021.gpkg) |\n\n### Crime data\nThe UK Police Data Portal allows you to access and generate tabular data for crime recorded in the UK across the different police forces. To download recorded crime data for London:\n\n1. Navigate to [data.police.uk](https://data.police.uk/) and click on **Downloads**.\n2. Under the data range select `January 2023` to `December 2023`.\n3. Under the **Custom download** tab select `Metropolitan Police Service` and `City of London Police`. Leave the other settings unchanged and click on **Generate file**.\n\n```{r}\n#| label: fig-police-data\n#| echo: False \n#| fig-cap: 'Downloading data on reported crimes through [data.police.uk](https://data.police.uk/)'\nknitr::include_graphics('images/w02/police-data.png')\n```\n\n4. It may take a few minutes for the download to be generated, so be patient. Once the **Download now** button appears, you can download the dataset.\n5. After downloading, unzip the file. You will find that the zip file contains 12 folders, one for each month of 2023. Each folder includes two files: one for the `Metropolitan Police Service` and one for the `City of London Police`.\n6. Create a new folder named `London-Crime` within your `data/attributes` directory, and copy all 12 folders with the data into this new folder.\n\nTo get started, let us create our first script. **File** -> **New File** -> **R Script**. Save your script as `w02-bike-theft.r`. \n\nWe will start by loading the libraries that we will need:\n\n```{r}\n#| label: 02-load-libraries\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| output: False\n#| tidy: True\n#| filename: 'R code'\n# load libraries\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(sf)\nlibrary(tmap)\nlibrary(osmdata)\n```\n\n::: {.callout-warning}\nYou may have to install some of these libraries if you have not used these before.\n:::\n\nAlthough we could read each individual crime file into R one by one and then combine them, we can actually accomplish this in a single step:\n\n```{r tidy='styler'}\n#| label: 02-combine-csv\n#| echo: True\n#| eval: True\n#| message: False\n#| filename: 'R code'\n# list all csv files\ncrime_df <- list.files(path='data/attributes/London-Crime/', full.names=TRUE, recursive=TRUE) |>\n  # read individual csv files\n  lapply(read_csv) |>\n  # bind together into one\n  bind_rows()\n\n# inspect\nhead(crime_df)\n```\n\n::: {.callout-note}\nDepending on your computer, processing this data may take some time due to the large volume involved. Once completed, you should have a dataframe containing **1,144,329** observations.\n:::\n\n::: {.callout-note}\nYou can further inspect the object using the `View()` function. \n:::\n\nThe column names contain spaces and are therefore not easily referenced. We can easily clean this up using the `janitor` package:\n\n```{r}\n#| label: 02-rename-fields\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# clean names\ncrime_df <- crime_df |>\n  clean_names()\n\n# inspect\nnames(crime_df)\n```\n\n::: {.callout-note}\nIf your `clean_names()` function returns an error, it is likely due to a conflict with another library that also includes a `clean_names()` function. In such cases, R cannot determine which one to use. To resolve this, you can specify the library explicitly by using `janitor::clean_names()`.\n:::\n\nFor our analysis, we are currently only interested in reported bicycle thefts, so we need to filter our data based on the `crime_type` column. We can start by examining the unique values in this column and then subset the data accordingly:\n\n```{r}\n#| label: 02-filter-crime\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# unique types\nunique(crime_df$crime_type)\n\n# filter\ntheft_bike <- crime_df |>\n  filter(crime_type == 'Bicycle theft')\n\n# inspect\nhead(theft_bike)\n```\n\nNow that we have filtered the data to only include reported bicycle thefts, we need to convert our dataframe into a spatial dataframe that maps the locations of the crimes using the recorded latitude and longitude coordinates. We can then project this spatial dataframe into the British National Grid (`EPSG:27700`).\n\n```{r}\n#| label: 02-locate-crime\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# to spatial data\ntheft_bike <- theft_bike |>\n  filter(!is.na(longitude) & !is.na(latitude)) |>\n  st_as_sf(coords = c('longitude', 'latitude'), crs = 4326) |>\n  st_transform(27700)\n\n# inspect\nhead(theft_bike)\n```\n\nLet's map the dataset to get an idea of how the data looks like, using the outline of London as background:\n\n```{r tidy='styler'} \n#| label: fig-02-theft-map\n#| fig-cap: Reported bicycle thefts in London.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| filename: 'R code'\n# read spatial dataset\nmsoa21 <- st_read('data/spatial/London-MSOA-2021.gpkg')\n\n# london outline\noutline <- msoa21 |>\n  st_union()\n\n# shape, polygon\ntm_shape(outline) +\n  \n  # specify colours\n  tm_polygons(\n    col = '#f0f0f0', \n  ) +\n  \n# shape, points\ntm_shape(theft_bike) + \n  \n  # specify colours\n  tm_dots(\n    col = '#fdc086',\n    size = 0.05,\n  ) +\n  \n  # set layout\n  tm_layout(\n    frame = FALSE,\n  )\n```\n\nWe can save the prepared dataset as a `GeoPackage` so that we can use it some other time:\n\n```{r}\n#| label: 02-save-crime\n#| classes: styled-output\n#| echo: True\n#| eval: False\n#| tidy: True\n#| filename: 'R code'\n# write\nst_write(theft_bike, 'data/spatial/London-BicycleTheft-2023.gpkg')\n```\n\n### Station data\nOpenStreetMap (OSM) is a free, editable map of the world. Each map element (whether a point, line, or polygon) in OSM is tagged with various attribute data. To download the station data we need, we must use the appropriate tags, represented as `key` and `value` pairs, to query the OSM database. In our case, we are looking for train stations, which fall under the *Public Transport* `key`, with a `value` of *station*. To limit our search to London, we can use the spatial extent of the 2021 MSOA boundaries as the bounding box for data extraction.\n\n```{r tidy='styler'} \n#| label: 02-station-data\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| warning: False\n#| cache: True\n#| filename: 'R code'\n# define our bbox coordinates, use WGS84\nbbox_london <- msoa21 |>\n  st_transform(4326) |>\n  st_bbox()\n  \n# osm query\nosm_stations <- opq(bbox = bbox_london) |>\n  add_osm_feature(key = 'public_transport', value = 'station') |>\n  osmdata_sf()\n```\n\n::: {.callout-warning}\nIn some cases, the OSM query may return an error, particularly when multiple users from the same location are executing the exact same query. If so, you can download a prepared copy of the data here: [[Download]](https://github.com/jtvandijk/GEOG0030/raw/refs/heads/main/data/spatial/London-OSM-Stations.RData). You can load this copy into R through `load('data/spatial/London-OSM-Stations.RData')`\n:::\n\nThe OSM query returns all data types, including lines and polygons tagged as stations. For our analysis, we only want to retain the point locations. In addition, we want to clip the results to the outline of London to exclude points that fall within the bounding box but outside the boundaries of Greater London.\n\n```{r}\n#| label: 02-station-point-data\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# extract points\nosm_stations <- osm_stations$osm_points |>\n  st_set_crs(4326) |>\n  st_transform(27700) |>\n  st_intersection(outline) |>\n  select(c('osm_id', 'name', 'network', 'operator', 'public_transport', 'railway'))\n\n# inspect\nhead(osm_stations)\n\n# inspect\nnrow(osm_stations)\n```\n\nThe total number of data points seems rather high. In fact, looking at the `railway` variable, several points are not tagged as station or do not have a value at all:\n\n```{r}\n#| label: 02-station-point-count\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# inspect values\ncount(osm_stations, railway)\n```\n\nThe number of points tagged as station in the railway field are most likely the only points in our dataset that represent actual stations, so we will only retain those points.\n\n```{r}\n#| label: 02-station-point-extract\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# extract train and underground stations\nosm_stations <- osm_stations |>\n  filter(railway == 'station')\n```\n\nLet's map the dataset to get an idea of how the data looks like, using the outline of London as background:\n\n```{r tidy='styler'} \n#| label: fig-02-station-map\n#| fig-cap: Train and underground stations in London.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| filename: 'R code'\n# shape, polygon\ntm_shape(outline) +\n  \n  # specify colours\n  tm_polygons(\n    col = '#f0f0f0', \n  ) +\n  \n# shape, points\ntm_shape(osm_stations) + \n  \n  # specify colours\n  tm_dots(\n    col = '#beaed4',\n    size = 0.05,\n  ) +\n  \n  # set layout\n  tm_layout(\n    frame = FALSE,\n  )\n```\nNow we have our data prepared, we can move on to analyse the extent to which bicycle theft in London cluster around stations. We can use both spatial queries and geometric operations to complete this analysis.\n\n### Spatial queries\nA spatial query is used to retrieve data based on its geographic location or spatial relationships. It uses spatial information from one or more layers to find features that meet specific criteria, such as proximity, intersection, or containment. For instance, we can use a spatial query to count all the bicycle thefts that have occurred within 500 metres of a train or underground station:\n\n```{r}\n#| label: 02-spatial-query-1\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# create a single station geometry\nosm_stations_comb <- osm_stations |>\n    st_union()\n\n# spatial query\ntheft_bike$d500 <- theft_bike |>\n    st_is_within_distance(osm_stations_comb, dist = 500, sparse = FALSE)\n\n# inspect\nhead(theft_bike)\n```\n\n::: {.callout-warning}\nThe above code converts the stations dataframe into a single geometry. This step is essential for `sf` to ensure that each point in the dataset is compared to every point in the stations dataframe. Without this conversion, the comparison would be done one station point at a time, storing only the last result rather than considering all station points simultaneously.\n:::\n\nWe can use the `count()` function to find out just how many thefts fall in each of these categories:\n\n```{r}\n#| label: 02-spatial-query-2\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# number of bicycle thefts within 500m of a station\ncount(theft_bike, d500)\n```\nMore than two-thirds of all reported bicycle thefts in London occur within 500 metres of a train or underground station. Of course, we can map the results for a visual inspection:\n\n```{r tidy='styler'} \n#| label: fig-02-theft-map-500m\n#| fig-cap: Reported bicycle thefts in London within 500 metres from a train or underground station.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| filename: 'R code'\n# shape, polygon\ntm_shape(outline) +\n  \n  # specify colours\n  tm_polygons(\n    col = '#f0f0f0', \n  ) +\n\n  # shape, points\n  tm_shape(theft_bike) + \n  \n  # specify column, colours\n  tm_dots(\n    col = 'd500',\n    size = 0.01,\n    palette = c('#f1a340','#998ec3'),\n    legend.show = FALSE\n  ) +\n\n  # set legend\n  tm_add_legend(\n    type = 'symbol',\n    labels = '> 500m',\n    col = '#f1a340'\n  ) +\n  \n  # set legend\n  tm_add_legend(\n    type = 'symbol',\n    labels = '< 500m',\n    col = '#998ec3'\n  ) +\n  \n  # shape, points\n  tm_shape(osm_stations) + \n  \n  # specify colours\n  tm_dots(\n    col = '#636363',\n    size = 0.03,\n  ) +\n  \n  # set legend\n  tm_add_legend(\n    type = 'symbol',\n    labels = 'Station',\n    col = '#636363'\n  ) +\n\n  # set layout\n  tm_layout(\n    frame = FALSE,\n    legend.position = c('left', 'bottom'),\n  )\n```\n\n### Geometric operations\nGeometric operations are used to manipulate and analyse the shapes and spatial properties of geometric objects, such as points, lines, and polygons. These operations include tasks like calculating intersections, buffering, and determining the distance between shapes. In this case, we can create 500-metre buffers around each station and then count how many bicycle thefts fall within these buffers.\n\n```{r}\n#| label: 02-spatial-buffer\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| filename: 'R code'\n# buffer\nosm_stations_buffer <- osm_stations |> \n  st_buffer(dist = 500) |> \n  st_union()\n\n# inspect\nhead(osm_stations_buffer)\n```\n\n::: {.callout-tip}\nWhen performing buffer analysis, the buffer sizes are determined by the units of the coordinate reference system (CRS) used. For instance, with the British National Grid, where the CRS is in metres, the buffer distance must be specified in metres.\n:::\n\nWe can map the results for a visual inspection:\n\n```{r tidy='styler'} \n#| label: fig-02-buffer-map\n#| fig-cap: Train and underground stations in London with a 500 metres buffer.\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| filename: 'R code'\n# shape, polygon\ntm_shape(outline) +\n  \n  # specify colours\n  tm_polygons(\n    col = '#f0f0f0', \n  ) +\n  \n# shape, polygon\ntm_shape(osm_stations_buffer) + \n  \n  # specify colours\n  tm_polygons(\n    col = '#beaed4',\n  ) +\n  \n  # set layout\n  tm_layout(\n    frame = FALSE,\n  )\n```\nWe can now use the `st_intersects` function to find out which reported bicycle thefts have occurred within 500 metres of a train or underground station.\n\n```{r}\n#| label: 02-intersect-buffer\n#| classes: styled-output\n#| echo: True\n#| eval: True\n#| tidy: True\n#| message: False\n#| filename: 'R code'\n# intersect buffer with bicycle thefts\ntheft_bike$d500_buffer <- theft_bike |> st_intersects(osm_stations_buffer, sparse = FALSE)\n\n# number of bicycle thefts within 500m of a station\ncount(theft_bike, d500_buffer)\n```\n\n::: {.callout-important}\nThe results are almost identical, with a small difference due to how the two methods define within and handle spatial relationships and boundaries. For instance, a point on the buffer's edge will be included in the intersect method, but may not meet the distance threshold required by `st_within_distance()`.\n:::\n\n## Assignment \nNow that we are familiar with basic spatial queries and geometric operations, we can conduct a similar analysis on the number of *serious* and *fatal* road crashed in London in 2022 and determine how many occurred on or near a main road. Try to do the following:\n\n1. Download the two datasets provided below and save them in the appropriate subfolder within your `data` directory. The datasets include:\n    * A `csv` file containing the number of road crashes that occurred in London in 2022, extracted from the UK's official road traffic casualty database using the [stats19](https://github.com/ropensci/stats19) R library.\n    * A `GeoPackage` file that contains main roads in London, extracted from the [Ordnance Survey Open Roads](https://www.ordnancesurvey.co.uk/products/os-open-roads) dataset.\n2. Calculate the number of *serious* and *fatal* road crashes that occurred within 100 metres and 500 metres of a main road.\n\n| File                                        | Type   | Link |\n| :------                                     | :------| :------ |\n| London STATS19 Road Collisions 2022         | `csv` | [Download](https://github.com/jtvandijk/GEOG0030/tree/master/data/attributes/London-Collisions-2022.csv) |\n| London OS Open Roads - Main Roads           | `GeoPackage` | [Download](https://github.com/jtvandijk/GEOG0030/raw/refs/heads/main/data/spatial/London-Open-Roads-Main.gpkg) |\n\n## Before you leave\nBoom. That is how you can conduct basic spatial queries and geometric operations and using R and `sf`. Yet more RGIS coming over the next couple of weeks, but [this concludes the tutorial for this week](https://www.youtube.com/watch?v=Xyt810Ahbxk). Time to check out that reading list?","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":false,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["assets/styles.css"],"toc":true,"toc-depth":4,"highlight-style":"atom-one","number-sections":true,"output-file":"02-operations.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","editor":"source","_quarto-vars":{"meta":{"title":"GEOG0030"},"urls":{"w01":"01-spatial.html","w02":"02-operations.html","w03":"03-point-pattern.html","w04":"04-autocorrelation.html","w05":"05-models.html","w06":"06-raster.html","w07":"07-geodemographics.html","w08":"08-network.html","w09":"09-maps.html","w10":"10-datavis.html"},"slides":{"week01":"https://github.com/jtvandijk/GEOG0030/blob/main/slides/w01-geo.pdf","week02":"https://github.com/jtvandijk/GEOG0030/blob/main/slides/w02-geo.pdf","week03":"https://github.com/jtvandijk/GEOG0030/blob/main/slides/w03-geo.pdf","week04":"https://github.com/jtvandijk/GEOG0030/blob/main/slides/w04-geo.pdf","week05":"https://github.com/jtvandijk/GEOG0030/blob/main/slides/w05-geo.pdf","week06":"https://github.com/jtvandijk/GEOG0030/blob/main/slides/w06-geo.pdf","week07":"https://github.com/jtvandijk/GEOG0030/blob/main/slides/w07-geo.pdf","week08":"https://github.com/jtvandijk/GEOG0030/blob/main/slides/w08-geo.pdf","week09":"https://github.com/jtvandijk/GEOG0030/blob/main/slides/w09-geo.pdf","week10":"https://github.com/jtvandijk/GEOG0030/blob/main/slides/w10-geo.pdf"}},"theme":{"light":"flatly","dark":"darkly"},"callout-appearance":"simple","smooth-scroll":true,"number-depth":4,"pagetitle":"{{< var meta.title >}}"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}